"""
From Classic cart-pole system implemented by Rich Sutton et al.
Copied from http://incompleteideas.net/sutton/book/code/pole.c
permalink: https://perma.cc/C9ZM-652R
"""

import math
import gym
from gym import spaces, logger
from gym.utils import seeding
import numpy as np
from time import sleep
import datetime
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import os


# Light_Path
path = "/home/francesco/Desktop/Ray-RLlib-Pible/gym_envs/envs"
# using PIR = 1 if you want to include the PIR in the simulation
state_trans = 900 # time in seconds
using_PIR = 1
I_PIR_detect = 0.000102; PIR_detect_time = 2.5

# Super-Capacitor values
SC_volt_min = 2.3; SC_volt_max = 5.4; SC_size = 1.5; SC_begin = 4

# Solar Panel values
V_solar_200lux = 1.5; I_solar_200lux = 0.000031;

# Communication values
I_Wake_up_Advertise = 0.00006; Time_Wake_up_Advertise = 11
I_BLE_Comm = 0.00025; Time_BLE_Comm = 4
I_BLE_Sens_1= ((I_Wake_up_Advertise * Time_Wake_up_Advertise) + (I_BLE_Comm * Time_BLE_Comm))/(Time_Wake_up_Advertise + Time_BLE_Comm)
Time_BLE_Sens_1 = Time_Wake_up_Advertise + Time_BLE_Comm
if using_PIR == 1:
	I_sleep = 0.0000055
else:
	I_sleep = 0.0000032

class PibleEnv(gym.Env):
    """
    Description:
	A representation o the Pible-mote as a gym environment to test RL algorithms
    Observation: 
        Type: Box(4)
        Num	Observation                 		Min     	Max
        0	Super-Capacitor Voltage level		2.3		5.4
	#0	Cart Position             		-4.8            4.8
        #1	Cart Velocity             		-Inf            Inf
        
    Actions:
        Type: Discrete(2)
        Num	Action
        0	15 min sensing-rate
	1	15 sec sensing-rate
        
    Reward:
        Reward equal to action if node alive (i.e. super capcitor voltage level > 2.3) else very negative (i.e. -300)
    Starting State:
        The super-capacitor voltage level is 4 volts
    Episode Termination:
        Episode terminates after 24 hours of simulation
    """
    
    #metadata = {
    #    'render.modes': ['human', 'rgb_array'],
    #    'video.frames_per_second' : 50
    #}

    def __init__(self, config):

        self.SC_volt = 4
        self.count = 0
        self.light_count = 0
        self.done = 0

        with open(path + "/Light_sample.txt", 'r') as f:
            content = f.readlines()
        self.light_input = [x.strip() for x in content]

        # Angle limit set to 2 * theta_threshold_radians so failing observation is still within bounds
        high = np.array([self.SC_volt])
            #self.state,
            #np.finfo(np.float32).max,
            #self.theta_threshold_radians * 2,
            #np.finfo(np.float32).max
	#])
	min = np.array([2.3])
        max = np.array([5.5])
        self.action_space = spaces.Discrete(4)
        self.observation_space = spaces.Box(min, max, dtype=np.float32)
        #self.observation_space = spaces.Box(-1.0, 1.0, dtype=np.float32)

    def step(self, action):
        assert self.action_space.contains(action), "%r (%s) invalid"%(action, type(action))

        line = self.light_input[self.light_count]
        self.light_count += 1
        line = line.split('|')
        self.time = datetime.datetime.strptime(line[0], '%m/%d/%y %H:%M:%S')
        self.PIR = int(line[7])
        light_pure = int(line[8])

        if self.time >= self.end_time:
            self.done = 1
        if self.light_count == len(self.light_input)-1:
            self.light_count = 0
            self.done = 1

        self.reward, self.perf = reward_func(action, self.SC_volt)
        self.SC_volt = energy_calc(self.SC_volt, light_pure, self.perf, self.PIR)

        return np.array([self.SC_volt]), self.reward, self.done, {}

    def reset(self):
        self.light_count == 0
        
        with open(path + "/Light_sample.txt", 'r') as f:
            for line in f:
                line = line.split('|')
                time = datetime.datetime.strptime(line[self.light_count], '%m/%d/%y %H:%M:%S')
                break

        self.end_time = time + datetime.timedelta(0, 24*60*60)
        self.done = 0
        self.PIR = 0
        self.SC_volt = SC_begin

        return np.array([self.SC_volt])


    '''
    def render(self, mode='human'):
        screen_width = 600
        screen_height = 400

        world_width = self.x_threshold*2
        scale = screen_width/world_width
        carty = 100 # TOP OF CART
        polewidth = 10.0
        polelen = scale * (2 * self.length)
        cartwidth = 50.0
        cartheight = 30.0

        if self.viewer is None:
            from gym.envs.classic_control import rendering
            self.viewer = rendering.Viewer(screen_width, screen_height)
            l,r,t,b = -cartwidth/2, cartwidth/2, cartheight/2, -cartheight/2
            axleoffset =cartheight/4.0
            cart = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
            self.carttrans = rendering.Transform()
            cart.add_attr(self.carttrans)
            self.viewer.add_geom(cart)
            l,r,t,b = -polewidth/2,polewidth/2,polelen-polewidth/2,-polewidth/2
            pole = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
            pole.set_color(.8,.6,.4)
            self.poletrans = rendering.Transform(translation=(0, axleoffset))
            pole.add_attr(self.poletrans)
            pole.add_attr(self.carttrans)
            self.viewer.add_geom(pole)
            self.axle = rendering.make_circle(polewidth/2)
            self.axle.add_attr(self.poletrans)
            self.axle.add_attr(self.carttrans)
            self.axle.set_color(.5,.5,.8)
            self.viewer.add_geom(self.axle)
            self.track = rendering.Line((0,carty), (screen_width,carty))
            self.track.set_color(0,0,0)
            self.viewer.add_geom(self.track)

            self._pole_geom = pole

        if self.state is None: return None

        # Edit the pole polygon vertex
        pole = self._pole_geom
        l,r,t,b = -polewidth/2,polewidth/2,polelen-polewidth/2,-polewidth/2
        pole.v = [(l,b), (l,t), (r,t), (r,b)]

        x = self.state
        cartx = x[0]*scale+screen_width/2.0 # MIDDLE OF CART
        self.carttrans.set_translation(cartx, carty)
        self.poletrans.set_rotation(-x[2])

        return self.viewer.render(return_rgb_array = mode=='rgb_array')

    def close(self):
        if self.viewer:
            self.viewer.close()
            self.viewer = None
    '''

def reward_func(action, SC_norm):
    perf = action
    reward = action
    '''
    if SC_norm <= SC_norm_die:
        reward = -300
    if perf == 0 and SC_norm <= SC_norm_die:
        reward = -100
    '''
    if perf == 0:
        reward = 1
    else:
        reward = 0
    
    return reward, perf

def energy_calc(SC_volt, light, perf, PIR):

    if perf == 3:
        effect = 60; effect_PIR = 7
    elif perf == 2:
        effect = 15; effect_PIR = 3
    elif perf == 1:
        effect = 3; effect_PIR = 2
    else:
        effect = 1; effect_PIR = 1

    Energy_Rem = SC_volt * SC_volt * 0.5 * SC_size

    if SC_volt <= SC_volt_min: # Node is death and not consuming energy
        Energy_Prod = state_trans * V_solar_200lux * I_solar_200lux * (light/200)
        Energy_Used = 0
    else: # Node is alive
        if using_PIR == 1:
            effect_PIR = 0

        Energy_Used = ((state_trans - (Time_BLE_Sens_1 * effect)) * SC_volt * I_sleep) + (Time_BLE_Sens_1 * effect * SC_volt * I_BLE_Sens_1) + (PIR * I_PIR_detect * PIR_detect_time * effect_PIR)
        Energy_Prod = state_trans * V_solar_200lux * I_solar_200lux * (light/200)

	# Energy cannot be lower than 0
        Energy_Rem = max(Energy_Rem - Energy_Used + Energy_Prod, 0)

        SC_volt = np.sqrt((2*Energy_Rem)/SC_size)

	# Setting Boundaries for Voltage
        if SC_volt > SC_volt_max:
            SC_volt = SC_volt_max

        if SC_volt < SC_volt_min:
            SC_volt = SC_volt_min

        return SC_volt

def pible_env_creator(env_config):
    return PibleEnv(env_config)
